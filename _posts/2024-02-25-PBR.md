---
title: "[Three.js] PBR (Physical-based rendering) material"
categories:
 - JavaScript
tags:
 - javascript
 - three.js
header:
  teaser: /assets/image/thumbnail/threejs.jpg
---

> Three.js provides the material attribute for a 3D object, which determines how the object reflects light and how the object is rendered in a camera. The properties of material are composed of base color, metalness, roughness, and so on. Moreover, we can decorate the surface of a 3D object by using texture maps. The texture map is a 2D image map which describes the characteristic of a material with respect to the UV map of the object surface. Thus, texture map helps us to make a realistic object.

## Prerequisite
#### Code changes
In order to concentrate the textures of the earth, fix the position of the earth object. Let the sun revolves around the earth by modifying the below lines
```js
scene.add(light);

function updateSystem(sec) {
    moon.position.set(0.4*Math.cos(w_moon*sec), 0, -0.4*Math.sin(w_moon*sec));
    earth_equator.position.set(3*Math.cos(w_orbit*sec), 0, -3*Math.sin(w_orbit*sec));
    earth.rotateY(w_rotate);
}
```
into
```js
sun.add(light);

function updateSystem(sec) {
    moon.position.set(0.4*Math.cos(w_moon*sec), 0, -0.4*Math.sin(w_moon*sec));
    sun.position.set(3*Math.cos(w_orbit*sec), 0, -3*Math.sin(w_orbit*sec));
    earth.rotateY(w_rotate);
}
```

Besides, the light has been attached into the revolving sun. This is much intuitive hierarchy. Then, the result is:

<img class="image" referrerpolicy="no-referrer" src="https://i.imgur.com/GTls7Se.gif">

#### Texture download
In the article, I’ll use `MeshPhongMaterial` for creating a realistic earth. Texture map for color, normal, bump, specular, etc. can be found at [here](https://www.solarsystemscope.com/textures/) or [here](https://planetpixelemporium.com/earth8081.html). Of course, you can use other texture map by searching with a keyword, “earth texture map”. Example for color and normal map are:

<img class="image480" referrerpolicy="no-referrer" src="https://i.imgur.com/74FRuTI.jpeg">

<img class="image480" referrerpolicy="no-referrer" src="https://i.imgur.com/5v81jPn.jpeg">

## Texture mapping
To use the downloaded texture map, Three.js provides `TextureLoader` class. It helps to load a texture map from a local file or URL. If we define `TextureLoader` with `load(url: String, onLoad: Function, onProgress: Function, onError: Function)` callback functions, the texture map is applied to the object asynchronously. In the following, we are about to apply color map, normal map, and specular map to the earth object.
```js
const material_earth = new THREE.MeshPhongMaterial();
const earth = new THREE.Mesh(geometry_sphere, material_earth);
earth.scale.set(0.2, 0.2, 0.2);

const loader = new THREE.TextureLoader();
loader.load('./assets/2k_earth_daymap.jpg', (texture)=>{
	material_earth.map = texture;
	material_earth.needsUpdate = true;
});
```

Notice that you have to run `material_earth.needsUpdate = true` when you update the attributes of the material after its construction.

<img class="image240" referrerpolicy="no-referrer" src="https://i.imgur.com/2A4CmrM.gif">

When we apply only specular map or normal map in order to see its effect, the results are as follows:
specular map only, 

<img class="image240" referrerpolicy="no-referrer" src="https://i.imgur.com/CZd7b55.gif">

normal map only, 

<img class="image240" referrerpolicy="no-referrer" src="https://i.imgur.com/iYo64jG.gif">

## Shadow
In the above, we’ve created the earth. Next, let’s create the moon.
```js
loader.load('./assets/moonmap2k.jpg', (texture)=>{
	material_moon.map = texture;
	material_moon.needsUpdate = true;
});
```

<img class="image" referrerpolicy="no-referrer" src="https://i.imgur.com/4ZKJaH2.png">

In the result, day and night are well-rendered at both earth and moon. But, an eclipse does not happen even though the earth and moon are in line with the sun. So, let’s activate a shadow effect of Three.js renderer. 
```js
renderer.shadowMap.enabled = true;
...

light.castShadow = true;
...

earth.castShadow = true;
earth.receiveShadow = true;
...

moon.castShadow = true;
moon.receiveShadow = true;
...
```

<img class="image" referrerpolicy="no-referrer" src="https://i.imgur.com/QKl1dnf.png">


Now, we can observe the eclipse. The boundary of shadow looks not much natural, but let's skip now. Then, for real scale, how about if we reduce the size of the moon? 

<img class="image" referrerpolicy="no-referrer" src="https://i.imgur.com/aljwGv9.png">

To make the shadow more realistic, we can set the size of shadow map and blur. 
```js
light.shadow.mapSize = new THREE.Vector2(4096, 4096);
light.shadow.radius = 20;
```

<img class="image" referrerpolicy="no-referrer" src="https://i.imgur.com/SQeCPC5.png">

In this way, we can enlarge the value of shadow map resolution for further planet, but it would be the waste of memory because only some of small surface are affected by shadows. So, it's time to use Shader. 

## Limitation
Overall, the material and texture makes an object almost realistic. But if we want to illustrate the night side of Earth, the shadow of cloud, and the high resolution of eclipse, we need shader material which will be covered in the following article.

## Entire code
```js
import * as THREE from 'three'
import { OrbitControls } from 'three/addons/controls/OrbitControls.js'

const canvas = document.createElement("canvas");
document.body.appendChild(canvas);

const renderer = new THREE.WebGLRenderer({canvas: canvas, alpha: true, antialias: true});
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.shadowMap.enabled = true;

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 5);

const geometry_sphere = new THREE.SphereGeometry(1, 30, 30);

const material_sun = new THREE.MeshBasicMaterial({color: 0xffaa00});
const sun = new THREE.Mesh(geometry_sphere, material_sun);

const material_earth = new THREE.MeshPhongMaterial({specular: new THREE.Color(0xFFFFFF), shininess: 3});
const earth = new THREE.Mesh(geometry_sphere, material_earth);
earth.scale.set(0.2, 0.2, 0.2);
earth.castShadow = true;
earth.receiveShadow = true;

const loader = new THREE.TextureLoader();
loader.load('./assets/2k_earth_daymap.jpg', (texture)=>{
    material_earth.map = texture;
    material_earth.needsUpdate = true;
});
loader.load('./assets/2k_earth_normal_map.tif', (texture)=>{
    material_earth.normalMap = texture;
    material_earth.normalScale = new THREE.Vector2(2, 2);
    material_earth.needsUpdate = true;
});
loader.load('./assets/2k_earth_specular_map.tif', (texture)=>{
    material_earth.specularMap = texture;
    material_earth.needsUpdate = true;
});

const material_moon = new THREE.MeshLambertMaterial();
const moon = new THREE.Mesh(geometry_sphere, material_moon);
moon.scale.set(0.05, 0.05, 0.05);
moon.castShadow = true;
moon.receiveShadow = true;

loader.load('./assets/moonmap2k.jpg', (texture)=>{
    material_moon.map = texture;
    material_moon.needsUpdate = true;
});

const light = new THREE.PointLight(0xffffff, 30);
light.position.set(0, 0, 0);
light.castShadow = true;
light.shadow.mapSize = new THREE.Vector2(4096, 4096);
light.shadow.radius = 20;

const earth_orbit = new THREE.Object3D();
const earth_equator = new THREE.Object3D();
const moon_orbit = new THREE.Object3D();
// earth_equator.rotateZ(23.5*Math.PI/180);

const scene = new THREE.Scene();
scene.add(sun);
sun.add(light);
scene.add(earth_orbit);
earth_orbit.add(earth_equator);
earth_equator.add(earth);
earth_equator.add(moon_orbit);
moon_orbit.add(moon);

const controls = new OrbitControls(camera, canvas);
controls.enableDamping = true;

const w_moon = 2;
const w_orbit = 0.5;
const w_rotate = 0.1;

function updateSystem(sec) {
    moon.position.set(0.4*Math.cos(w_moon*sec), 0, -0.4*Math.sin(w_moon*sec));
    sun.position.set(3*Math.cos(w_orbit*sec), 0, -3*Math.sin(w_orbit*sec));
    earth.rotateY(w_rotate);
}

function animate (msec) {
    requestAnimationFrame(animate);
    
    updateSystem(msec * 0.001);

    controls.update();
	renderer.render(scene, camera);
}
animate();
```


[^rAF]: https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame
<div id="wrapper">
    <canvas id='webgl'></canvas>
</div>

<style>
    #wrapper {
        position: relative;
    }
    canvas {
        position: relative;
    }
    .dg {
        /* min-height: 16px; */
        max-height: calc(100% - 6px);
        height: 100%;
        overflow-x: hidden;
    }
    .dg li {
        margin-bottom: 0px;
    }
    .dg ul {
        position: inherit;
        top: 20px;
        height: unset !important;
    }
    .dg .close-button {
        position: absolute;
        top: 0;
    }
</style>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
        }
    }
</script>

<script src="//cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
<script type="module">
    import * as THREE from 'three'
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
    
    const legendre = /* glsl */ `
    float legendre(in int l, in int m, in float x) {
        if (l == 0) {
            return 1.0;
        } else if (l == 1) {
            if (m == 0) return 1.7321 * x;
            else if (m == 1) return -1.2247 * pow(1.0 - x*x, 0.5);
            else if (m == -1) return 1.2247 * pow(1.0 - x*x, 0.5);
        } else if (l == 2) {
            if (m == 0) return 1.118 * (3.0 * x * x - 1.0);
            else if (m == 1) return -2.7386 * x * pow(1.0 - x*x, 0.5);
            else if (m == 2) return 1.3693 * (1.0 - x*x);
            else if (m == -1) return 2.7386 * x * pow(1.0 - x*x, 0.5);
            else if (m == -2) return 1.3693 * (1.0 - x*x);
        } else if (l == 3) {
            if (m == 0) return 1.3228 * (5.0 * x * x * x - 3.0 * x);
            else if (m == 1) return 1.1456 * (1.0 - 5.0*x*x) * pow(1.0 - x*x, 0.5);
            else if (m == 2) return 3.6228 * x * (1.0 - x*x);
            else if (m == 3) return -1.479 * pow(1.0 - x*x, 1.5);
            else if (m == -1) return -1.1456 * (1.0 - 5.0*x*x) * pow(1.0 - x*x, 0.5);
            else if (m == -2) return 3.6228 * x * (1.0 - x*x);
            else if (m == -3) return 1.479 * pow(1.0 - x*x, 1.5);
        } else if (l == 4) {
            if (m == 0) return 9.0*x*x*(x*x - 1.0) + 1.125*pow(x*x - 1.0, 2.) + 3.0*x*x*x*x;
            else if (m == 1) return -1.0*pow(1.0 - 1.0*x*x, 0.5)*(5.0312*x*(x*x - 1.0) + 6.7082*x*x*x);
            else if (m == 2) return -(8.301*x*x - 1.1859)*(x*x - 1.0);
            else if (m == 3) return -4.4371*x*pow(1.0 - 1.0*x*x, 1.5);
            else if (m == 4) return 1.5687*pow(x*x - 1.0, 2.);
            else if (m == -1) return 0.0017469*pow(1.0 - 1.0*x*x, 0.5)*(2880.0*x*(x*x - 1.0) + 3840.0*x*x*x);
            else if (m == -2) return -0.14823*(20160.0*x*x - 2880.0)*(0.0027778*x*x - 0.0027778);
            else if (m == -3) return 4.4371*x*pow(1.0 - 1.0*x*x, 1.5);
            else if (m == -4) return 1.5687*pow(x*x - 1.0, 2.);
        }
    }
    `;

    const fragment = /* glsl */ `
    uniform float coeffRed[25];
    uniform float coeffGreen[25];
    uniform float coeffBlue[25];
    varying vec3 vPosition;

    #define PI (3.141592)
    #define L (4)

    void main( void ) {
        float x = -vPosition.x;
        float y = vPosition.z;
        float z = vPosition.y;
        float theta = atan(sqrt(x*x + y*y), z); // 0 to PI
        float phi = atan(y, x) + PI; // 0 to 2PI

        vec3 color;
        int k = 0;
        for (int l = 0; l <= L; ++l) {
            for (int m = -l; m <= l; ++m) {
                float P = legendre(l,m,cos(theta));
                float e = (m >= 0) ? cos(float(m)*phi) : sin(float(m)*phi);
                color += vec3(coeffRed[k] * P * e, coeffGreen[k] * P * e, coeffBlue[k] * P * e);
                ++k;
            }
        }
        gl_FragColor = vec4(0.5 / sqrt(PI) * color, 1.);
    }
    `;

    const vertex = /* glsl */ `
    uniform float coeffMono[25];
    varying vec3 vPosition;

    #define PI (3.141592)
    #define L (4)

    void main() {
        vPosition = mat3(modelMatrix) * position;

        float x = -vPosition.x;
        float y = vPosition.z;
        float z = vPosition.y;
        float theta = atan(sqrt(x*x + y*y), z); // 0 to PI
        float phi = atan(y, x) + PI; // 0 to 2PI
        if (x == 0. && y == 0.) phi = 0.;

        float scale = 0.;
        int k = 0;
        for (int l = 0; l <= L; ++l) {
            for (int m = -l; m <= l; ++m) {
                float P = legendre(l,m,cos(theta));
                float e = (m >= 0) ? cos(float(m)*phi) : sin(float(m)*phi);
                scale += coeffMono[k++] * P * e;
            }
        }

        gl_Position = projectionMatrix * modelViewMatrix * vec4(position + 0.05 * scale * normal, 1.0);
    }
    `;

    let fragment_shader = legendre + fragment;
    let vertex_shader = legendre + vertex;

    const canvas = document.getElementById('webgl');

    const renderer = new THREE.WebGLRenderer({canvas: canvas, alpha: true, antialias: true});
    renderer.setSize( window.innerWidth, window.innerHeight );
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.background = 'linear-gradient(#303438 0%, #000000 30%, #888480 100%)';

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0,0,3);

    const geometry = new THREE.SphereGeometry(1, 64, 64);
    const material = new THREE.ShaderMaterial({
        uniforms: {
            coeffRed: { value: new Array(25).fill(0) },
            coeffGreen: { value: new Array(25).fill(0) },
            coeffBlue: { value: new Array(25).fill(0) },
            coeffMono: { value: new Array(25).fill(0) },
        },
        vertexShader: vertex_shader,
        fragmentShader: fragment_shader,
    })
    const sphere = new THREE.Mesh(geometry, material);

    const scene = new THREE.Scene();
    scene.add(sphere);

    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.enablePan = false;

    let coeffZero = { k00: 0, k1m1: 0, k10: 0, k1p1: 0, k2m2: 0, k2m1: 0, k20: 0, k2p1: 0, k2p2: 0, k3m3: 0, k3m2: 0, k3m1: 0, k30: 0, k3p1: 0, k3p2: 0, k3p3: 0, k4m4: 0, k4m3: 0, k4m2: 0, k4m1: 0, k40: 0, k4p1: 0, k4p2: 0, k4p3: 0, k4p4: 0 };
    let coeffRed = { k00: 0, k1m1: 0, k10: 0, k1p1: 0, k2m2: 0, k2m1: 0, k20: 0, k2p1: 0, k2p2: 0, k3m3: 0, k3m2: 0, k3m1: 0, k30: 0, k3p1: 0, k3p2: 0, k3p3: 0, k4m4: 0, k4m3: 0, k4m2: 0, k4m1: 0, k40: 0, k4p1: 0, k4p2: 0, k4p3: 0, k4p4: 0 };
    let coeffGreen = { k00: 0, k1m1: 0, k10: 0, k1p1: 0, k2m2: 0, k2m1: 0, k20: 0, k2p1: 0, k2p2: 0, k3m3: 0, k3m2: 0, k3m1: 0, k30: 0, k3p1: 0, k3p2: 0, k3p3: 0, k4m4: 0, k4m3: 0, k4m2: 0, k4m1: 0, k40: 0, k4p1: 0, k4p2: 0, k4p3: 0, k4p4: 0 };
    let coeffBlue = { k00: 0, k1m1: 0, k10: 0, k1p1: 0, k2m2: 0, k2m1: 0, k20: 0, k2p1: 0, k2p2: 0, k3m3: 0, k3m2: 0, k3m1: 0, k30: 0, k3p1: 0, k3p2: 0, k3p3: 0, k4m4: 0, k4m3: 0, k4m2: 0, k4m1: 0, k40: 0, k4p1: 0, k4p2: 0, k4p3: 0, k4p4: 0 };
    let coeffMono = { k00: 0, k1m1: 0, k10: 0, k1p1: 0, k2m2: 0, k2m1: 0, k20: 0, k2p1: 0, k2p2: 0, k3m3: 0, k3m2: 0, k3m1: 0, k30: 0, k3p1: 0, k3p2: 0, k3p3: 0, k4m4: 0, k4m3: 0, k4m2: 0, k4m1: 0, k40: 0, k4p1: 0, k4p2: 0, k4p3: 0, k4p4: 0 };

    const setting = {
        mode: "red",
        reset: function(){ Object.assign(this, coeffZero); updateCoeffSH(); },
        k00: 0, k1m1: 0, k10: 0, k1p1: 0, k2m2: 0, k2m1: 0, k20: 0, k2p1: 0, k2p2: 0, k3m3: 0, k3m2: 0, k3m1: 0, k30: 0, k3p1: 0, k3p2: 0, k3p3: 0, k4m4: 0, k4m3: 0, k4m2: 0, k4m1: 0, k40: 0, k4p1: 0, k4p2: 0, k4p3: 0, k4p4: 0
    };

    const gui = new dat.GUI();
    const canvasContainer = document.getElementById("wrapper");
    canvasContainer.appendChild(gui.domElement);
    gui.domElement.style.marginRight = '0px';
    gui.domElement.style.position = 'absolute';
    gui.domElement.style.top = '0px';
    gui.domElement.style.right = '0px';
    gui.add(setting, 'mode', {'Red': 'red', 'Green': 'green', 'Blue': 'blue', 'Height': 'mono'}).name('Mode').listen().onChange(updateMode);

    gui.add(setting, 'reset').name('Reset');

    const l0 = gui.addFolder('l = 0');
    l0.add(setting, 'k00', -1, 1, 0.01).name("m = 0").listen().onChange(updateCoeffSH);

    const l1 = gui.addFolder('l = 1');
    l1.add(setting, 'k1m1', -1, 1, 0.01).name("m = -1").listen().onChange(updateCoeffSH);
    l1.add(setting, 'k10', -1, 1, 0.01).name("m = 0").listen().onChange(updateCoeffSH);
    l1.add(setting, 'k1p1', -1, 1, 0.01).name("m = 1").listen().onChange(updateCoeffSH);

    const l2 = gui.addFolder('l = 2');
    l2.add(setting, 'k2m2', -1, 1, 0.01).name("m = -2").listen().onChange(updateCoeffSH);
    l2.add(setting, 'k2m1', -1, 1, 0.01).name("m = -1").listen().onChange(updateCoeffSH);
    l2.add(setting, 'k20', -1, 1, 0.01).name("m = 0").listen().onChange(updateCoeffSH);
    l2.add(setting, 'k2p1', -1, 1, 0.01).name("m = 1").listen().onChange(updateCoeffSH);
    l2.add(setting, 'k2p2', -1, 1, 0.01).name("m = 2").listen().onChange(updateCoeffSH);

    const l3 = gui.addFolder('l = 3');
    l3.add(setting, 'k3m3', -1, 1, 0.01).name("m = -3").listen().onChange(updateCoeffSH);
    l3.add(setting, 'k3m2', -1, 1, 0.01).name("m = -2").listen().onChange(updateCoeffSH);
    l3.add(setting, 'k3m1', -1, 1, 0.01).name("m = -1").listen().onChange(updateCoeffSH);
    l3.add(setting, 'k30', -1, 1, 0.01).name("m = 0").listen().onChange(updateCoeffSH);
    l3.add(setting, 'k3p1', -1, 1, 0.01).name("m = 1").listen().onChange(updateCoeffSH);
    l3.add(setting, 'k3p2', -1, 1, 0.01).name("m = 2").listen().onChange(updateCoeffSH);
    l3.add(setting, 'k3p3', -1, 1, 0.01).name("m = 3").listen().onChange(updateCoeffSH);

    const l4 = gui.addFolder('l = 4');
    l4.add(setting, 'k4m4', -1, 1, 0.01).name("m = -4").listen().onChange(updateCoeffSH);
    l4.add(setting, 'k4m3', -1, 1, 0.01).name("m = -3").listen().onChange(updateCoeffSH);
    l4.add(setting, 'k4m2', -1, 1, 0.01).name("m = -2").listen().onChange(updateCoeffSH);
    l4.add(setting, 'k4m1', -1, 1, 0.01).name("m = -1").listen().onChange(updateCoeffSH);
    l4.add(setting, 'k40', -1, 1, 0.01).name("m = 0").listen().onChange(updateCoeffSH);
    l4.add(setting, 'k4p1', -1, 1, 0.01).name("m = 1").listen().onChange(updateCoeffSH);
    l4.add(setting, 'k4p2', -1, 1, 0.01).name("m = 2").listen().onChange(updateCoeffSH);
    l4.add(setting, 'k4p3', -1, 1, 0.01).name("m = 3").listen().onChange(updateCoeffSH);
    l4.add(setting, 'k4p4', -1, 1, 0.01).name("m = 4").listen().onChange(updateCoeffSH);

    function mergeExistingFields(target, source) {
        for (const key in source) {
        if (key in target) {
            target[key] = source[key];
        }
        }
        return target;
    }
    
    function updateMode () {
        if (setting.mode == 'red') {
            Object.assign(setting, coeffRed);
        } else if (setting.mode == 'green') {
            Object.assign(setting, coeffGreen);
        } else if (setting.mode == 'blue') {
            Object.assign(setting, coeffBlue);
        } else if (setting.mode == 'mono') {
            Object.assign(setting, coeffMono);
        }
    }

    function updateCoeffSH () {
        const newValue = [
            setting.k00,
            setting.k1m1,
            setting.k10,
            setting.k1p1,
            setting.k2m2,
            setting.k2m1,
            setting.k20,
            setting.k2p1,
            setting.k2p2,
            setting.k3m3,
            setting.k3m2,
            setting.k3m1,
            setting.k30,
            setting.k3p1,
            setting.k3p2,
            setting.k3p3,
            setting.k4m4,
            setting.k4m3,
            setting.k4m2,
            setting.k4m1,
            setting.k40,
            setting.k4p1,
            setting.k4p2,
            setting.k4p3,
            setting.k4p4
        ];

        if (setting.mode == 'red') {
            mergeExistingFields(coeffRed, setting);
            material.uniforms.coeffRed.value = newValue;
        } else if (setting.mode == 'green') {
            mergeExistingFields(coeffGreen, setting);
            material.uniforms.coeffGreen.value = newValue;
        } else if (setting.mode == 'blue') {
            mergeExistingFields(coeffBlue, setting);
            material.uniforms.coeffBlue.value = newValue;
        } else if (setting.mode == 'mono') {
            mergeExistingFields(coeffMono, setting);
            material.uniforms.coeffMono.value = newValue;
        }
    }

    function animate (msec) {
        requestAnimationFrame(animate);

        controls.update();
        renderer.render(scene, camera);
    }

    animate();
</script>
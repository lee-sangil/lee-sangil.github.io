<div id="wrapper">
    <canvas id='webgl'></canvas>
    <svg id="enterFullscreen" class="fullscreen" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>Enter Fullscreen</title><path d="M5,5H10V7H7V10H5V5M14,5H19V10H17V7H14V5M17,14H19V19H14V17H17V14M10,17V19H5V14H7V17H10Z" /></svg>
    <svg id="leaveFullscreen" class="fullscreen" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>Leave Fullscreen</title><path d="M14,14H19V16H16V19H14V14M5,14H10V19H8V16H5V14M8,5H10V10H5V8H8V5M19,8V10H14V5H16V8H19Z" /></svg>
</div>

<style>
    #wrapper {
        position: relative;
        width: 100%;
        height: 50vh;
    }
    canvas {
        position: relative;
    }
    .dg {
        min-height: 16px;
        max-height: 100%;
        height: fit-content;
        overflow-x: hidden;
    }
    .dg.main {
        padding-bottom: 20px;
    }
    .dg.main > div:first-child {
        position: relative !important;
    }
    .dg li {
        margin-bottom: 0px;
    }
    .dg ul {
        position: inherit;
        top: 20px;
        height: unset !important;
    }
    .dg .close-button {
        position: absolute;
        top: 0;
    }
    .fullscreen {
        fill: lightgray;
        position: absolute;
        top: 1vh;
        left: 1vw;
        margin: 5px;
        width: 24px;
        height: 24px;
        cursor : pointer;
    }
    .fullscreen:hover {
        background-color:rgba(255,255,255,0.3);
        border-radius: 50%;
    }
    #leaveFullscreen {
        visibility: hidden;
    }
</style>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
        }
    }
</script>

<script src="//cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- 1. 기본 씬 설정 (Scene Setup) ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000); // 검은 배경

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(10, 10, 10); // 초기 카메라 위치

    const canvas = document.getElementById('webgl');
    const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // --- 2. 조명 및 헬퍼 설정 (Lights & Helpers) ---
    const ambientLight = new THREE.AmbientLight(0x808080); // 부드러운 주변광
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight( 0xffffff, 1 );
    scene.add(directionalLight);

    // 요청사항 1: AxisHelper (X: Red, Y: Green, Z: Blue)
    const axesHelper = new THREE.AxesHelper(2);
    axesHelper.setColors(0xff0000, 0x0000ff, 0x00ff00);
    scene.add(axesHelper);

    // 그리드 헬퍼 (바닥 기준)
    const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
    scene.add(gridHelper);

    // --- 3. 복소수 연산 로직 (Complex Math Logic) ---
    // z = x + iy
    // f(z) = az^3 + bz^2 + cz + d
    // 높이(Y) = |f(z)| (Magnitude)

    function getComplexMagnitude(x, y, a, b, c, d, e) {
        // 1. z
        let z_r = x;
        let z_i = y;

        // 2. z^2 = (x^2 - y^2) + i(2xy)
        let z2_r = (z_r * z_r) - (z_i * z_i);
        let z2_i = 2 * z_r * z_i;

        // 3. z^3 = z^2 * z
        // (z2_r + i*z2_i)(z_r + i*z_i) = (z2_r*z_r - z2_i*z_i) + i(z2_r*z_i + z2_i*z_r)
        let z3_r = (z2_r * z_r) - (z2_i * z_i);
        let z3_i = (z2_r * z_i) + (z2_i * z_r);

        // 4. z^4 = z^3 * z
        // (z3_r + i*z3_i)(z_r + i*z_i) = (z3_r*z_r - z3_i*z_i) + i(z3_r*z_i + z3_i*z_r)
        let z4_r = (z3_r * z_r) - (z3_i * z_i);
        let z4_i = (z3_r * z_i) + (z3_i * z_r);

        // 5. f(z) 계산 (각 항을 더함)
        // 실수부: a*z4_r + b*z3_r + c*z2_r + d*z_r + e
        // 허수부: a*z4_i + b*z3_i + c*z2_i + d*z_i
        let result_r = a * z4_r + b * z3_r + c * z2_r + d * z_r + e;
        let result_i = a * z4_i + b * z3_i + c * z2_i + d * z_i;

        // 5. 크기(Magnitude) 반환: sqrt(real^2 + imag^2)
        return Math.sqrt(result_r * result_r + result_i * result_i);
    }

    function createCustomGrid(size, spacing) {
        const halfSize = size / 2;
        const vertices = [];
        const division = spacing * 0.1;

        // spacing: grid spacing
        // division: 1 / num of line segments

        // X축(실수부) 평행선 생성
        for (let i = -halfSize; i <= halfSize; i += spacing) {
            for (let j = -halfSize; j <= halfSize-division; j += division) {
                vertices.push(i, 0, j);
                vertices.push(i, 0, j+division);
            }
        }

        // Z축(허수부) 평행선 생성
        for (let j = -halfSize; j <= halfSize; j += spacing) {
            for (let i = -halfSize; i <= halfSize-division; i += division) {
                vertices.push(i, 0, j);
                vertices.push(i+division, 0, j);
            }
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        return geometry;
    }

    // --- 4. 메쉬 생성 (Mesh Generation) ---
    // PlaneGeometry 생성 (세그먼트를 높여 부드럽게 만듦)
    const size = 10;
    const geometry = new THREE.PlaneGeometry(size, size, 100, 100);
    
    // Plane은 기본적으로 XY 평면이므로 XZ(바닥) 평면과 맞추기 위해 회전
    geometry.rotateX(-Math.PI / 2);

    // 재질: 이미지와 비슷하게 반투명한 시안(Cyan) 색상에 와이어프레임 느낌 추가
    const material = new THREE.MeshPhongMaterial({ 
        color: 0x0088ff, 
        side: THREE.DoubleSide,
        specular: 0x88ddff,
        shininess: 20,
        transparent: true,
        opacity: 0.9,
        wireframe: false
    });

    const planeMesh = new THREE.Mesh(geometry, material);
    scene.add(planeMesh);

    // **[수정] 2. 커스텀 그리드(LineSegments) 생성**
    const gridGeometry = createCustomGrid(size, 0.5);

    const gridMaterial = new THREE.LineBasicMaterial({
        color: 0xffffff, // 밝은 시안 색상
        linewidth: 2 // 라인 두께 설정 (브라우저나 플랫폼에 따라 무시될 수 있음)
    });

    const gridMesh = new THREE.LineSegments(gridGeometry, gridMaterial);
    scene.add(gridMesh);

    // --- 5. GUI 및 업데이트 로직 (GUI & Update) ---
    // 요청사항 2: dat.gui (lil-gui) 설정
    const gui = new dat.GUI({ title: 'Cubic polynomial' });
    const canvasContainer = document.getElementById("wrapper");
    canvasContainer.appendChild(gui.domElement);
    gui.domElement.style.marginRight = '0px';
    gui.domElement.style.position = 'absolute';
    gui.domElement.style.top = '0px';
    gui.domElement.style.right = '0px';
    
    const params = {
        a4: 0.1,  // a_4 of x^4 (quartic coeff)
        a3: 0.0,  // a_3 of x^3 (cubic coeff)
        a2: 0.0,  // a_2 of x^2 (quadratic coeff)
        a1: 0.0,  // a_1 (linear coeff)
        a0: 0.0,  // a_0 (constant)
        scaleX: 0.5, // 시각적 높이 조절용
        scaleY: 0.5, // 시각적 높이 조절용
        scaleZ: 0.5, // 시각적 높이 조절용
    };

    // GUI 컨트롤 추가
    const coeffs = gui.addFolder('Coefficients');
    coeffs.add(params, 'a4', -1.0, 1.0).step(0.01).name('a').onChange(updateSurface);
    coeffs.add(params, 'a3', -1.0, 1.0).step(0.01).name('b').onChange(updateSurface);
    coeffs.add(params, 'a2', -2.0, 2.0).step(0.01).name('c').onChange(updateSurface);
    coeffs.add(params, 'a1', -5.0, 5.0).step(0.01).name('d').onChange(updateSurface);
    coeffs.add(params, 'a0', -5.0, 5.0).step(0.01).name('e').onChange(updateSurface);

    const scale = gui.addFolder('Plot scale');
    scale.add(params, 'scaleX', 0.1, 2.0).step(0.01).name('X Scale').onChange(updateSurface);
    scale.add(params, 'scaleY', 0.1, 2.0).step(0.01).name('Y Scale').onChange(updateSurface);
    scale.add(params, 'scaleZ', 0.1, 2.0).step(0.01).name('Z Scale').onChange(updateSurface);

    // 지오메트리 업데이트 함수
    function updateSurface() {
        const positions = geometry.attributes.position.array;
        const vertexCount = positions.length / 3;

        for (let i = 0; i < vertexCount; i++) {
            const x = positions[3 * i] * params.scaleX; // Real input
            const y = positions[3 * i + 2] * params.scaleY; // Imaginary input

            // 복소함수 계산
            const magnitude = getComplexMagnitude(
                x, y, params.a4, params.a3, params.a2, params.a1, params.a0
            );

            // 높이(Y) 설정
            positions[3 * i + 1] = magnitude * params.scaleZ;
        }

        // Three.js에게 정점 위치와 법선이 변경되었음을 알림
        geometry.attributes.position.needsUpdate = true;
        geometry.computeVertexNormals();

        const gridPositions = gridGeometry.attributes.position.array;
        const gridVertexCount = gridPositions.length / 3;
        
        // 그리드 점들의 높이를 계산하여 업데이트
        for (let i = 0; i < gridVertexCount; i++) {
            const x = gridPositions[3 * i] * params.scaleX; // Real input
            const y = gridPositions[3 * i + 2] * params.scaleY; // Imaginary input
            
            const magnitude = getComplexMagnitude(
                x, y, params.a4, params.a3, params.a2, params.a1, params.a0
            );

            // 높이(Y) 설정
            gridPositions[3 * i + 1] = magnitude * params.scaleZ + 0.005; // 표면보다 살짝 위로 띄워 Z-fighting 방지
        }
        
        gridGeometry.attributes.position.needsUpdate = true;
    }

    // 초기 실행
    updateSurface();

    // --- 6. 렌더링 루프 (Render Loop) ---
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }

    // 화면 크기 변경 대응
    window.onresize = resize;
    
    animate();

    function toggleFullscreen(status) {
        const wrapperDom = document.getElementById('wrapper');
        const enterFullscreenDom = document.getElementById('enterFullscreen');
        const leaveFullscreenDom = document.getElementById('leaveFullscreen');

        if (status) {
            document.body.style.overflowY = 'hidden';

            wrapperDom.style.position = 'fixed';
            wrapperDom.style.top = '0';
            wrapperDom.style.left = '0';
            wrapperDom.style.height = '100vh';
            wrapperDom.style.zIndex = '1000';

            enterFullscreenDom.style.visibility = 'hidden';
            leaveFullscreenDom.style.visibility = 'visible';
        }
        else {
            document.body.style.overflowY = '';

            wrapperDom.style.position = '';
            wrapperDom.style.top = '';
            wrapperDom.style.left = '';
            wrapperDom.style.height = '';
            wrapperDom.style.zIndex = '';

            enterFullscreenDom.style.visibility = 'visible';
            leaveFullscreenDom.style.visibility = 'hidden';
        }

        resize();
    }

    const enterFullscreenDom = document.getElementById('enterFullscreen');
    const leaveFullscreenDom = document.getElementById('leaveFullscreen');

    enterFullscreenDom.addEventListener('click', ()=>toggleFullscreen(true));
    leaveFullscreenDom.addEventListener('click', ()=>toggleFullscreen(false));

    window.addEventListener('keydown', (event)=>{
        if (event.key == "Escape") toggleFullscreen(false);
    });

    function resize() {
        const wrapperDom = document.getElementById('wrapper');

        const width = wrapperDom.clientWidth;
        const height = wrapperDom.clientHeight;

        const canvas = document.getElementById('webgl');
        canvas.width = width * window.devicePixelRatio;
        canvas.height = height * window.devicePixelRatio;

        renderer.setSize(width, height);

        camera.aspect = width / height;
        camera.updateProjectionMatrix();
    }

    resize();
</script>
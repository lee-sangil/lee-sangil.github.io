<div id="wrapper">
    <canvas id='webgl'></canvas>
    <svg id="enterFullscreen" class="fullscreen" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>Enter Fullscreen</title><path d="M5,5H10V7H7V10H5V5M14,5H19V10H17V7H14V5M17,14H19V19H14V17H17V14M10,17V19H5V14H7V17H10Z" /></svg>
    <svg id="leaveFullscreen" class="fullscreen" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>Leave Fullscreen</title><path d="M14,14H19V16H16V19H14V14M5,14H10V19H8V16H5V14M8,5H10V10H5V8H8V5M19,8V10H14V5H16V8H19Z" /></svg>
</div>

<style>
    #wrapper {
        position: relative;
        width: 100%;
        height: 50vh;
    }
    canvas {
        position: relative;
    }
    .dg {
        min-height: 16px;
        max-height: 100%;
        height: fit-content;
        overflow-x: hidden;
    }
    .dg.main {
        padding-bottom: 20px;
    }
    .dg.main > div:first-child {
        position: relative !important;
    }
    .dg li {
        margin-bottom: 0px;
    }
    .dg ul {
        position: inherit;
        top: 20px;
        height: unset !important;
    }
    .dg .property-name {
        width: 25%;
    }
    .dg .c {
        width: 72%;
    }
    .dg .slider {
        width: 60%;
    }
    .dg .has-slider input[type=text] {
        width: 37%;
    }
    .dg .close-button {
        position: absolute;
        top: 0;
    }
    .fullscreen {
        fill: lightgray;
        position: absolute;
        top: 1vh;
        left: 1vw;
        margin: 5px;
        width: 24px;
        height: 24px;
        cursor : pointer;
    }
    .fullscreen:hover {
        background-color:rgba(255,255,255,0.3);
        border-radius: 50%;
    }
    #leaveFullscreen {
        visibility: hidden;
    }
</style>

<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.180.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.180.0/examples/jsm/"
    }
}
</script>

<script src="//cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/14.8.1/math.min.js" integrity="sha512-ix7qh7Gu4nTiTEktF0EWQAsn0cGwuiDJwuxdX4GGpivcx+PxYdJ/j0nlWyUTONg2bOQV98vk+x+Ee6zYpB5wyA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script type="module">
    var Polyfit = (function () {
        /**
         * Polyfit
         * @constructor
         * @param {number[]|Float32Array|Float64Array} x
         * @param {number[]|Float32Array|Float64Array} y
         */
        function Polyfit(x, y) {
            // Make sure we return an instance
            if (!(this instanceof Polyfit)) {
                return new Polyfit(x, y);
            }
            // Check that x any y are both arrays of the same type
            if (!((x instanceof Array && y instanceof Array) ||
                (x instanceof Float32Array && y instanceof Float32Array) ||
                (x instanceof Float64Array && y instanceof Float64Array))) {
                throw new Error('x and y must be arrays');
            }
            if (x instanceof Float32Array) {
                this.FloatXArray = Float32Array;
            }
            else if (x instanceof Float64Array) {
                this.FloatXArray = Float64Array;
            }
            // Make sure we have equal lengths
            if (x.length !== y.length) {
                throw new Error('x and y must have the same length');
            }
            this.x = x;
            this.y = y;
        }
        /**
         * Perform gauss-jordan division
         *
         * @param {number[][]|Float32Array[]|Float64Array[]} matrix - gets modified
         * @param {number} row
         * @param {number} col
         * @param {number} numCols
         * @returns void
         */
        Polyfit.gaussJordanDivide = function (matrix, row, col, numCols) {
            for (var i = col + 1; i < numCols; i++) {
                matrix[row][i] /= matrix[row][col];
            }
            matrix[row][col] = 1;
        };
        /**
         * Perform gauss-jordan elimination
         *
         * @param {number[][]|Float64Array[]} matrix - gets modified
         * @param {number} row
         * @param {number} col
         * @param {number} numRows
         * @param {number} numCols
         * @returns void
         */
        Polyfit.gaussJordanEliminate = function (matrix, row, col, numRows, numCols) {
            for (var i = 0; i < numRows; i++) {
                if (i !== row && matrix[i][col] !== 0) {
                    for (var j = col + 1; j < numCols; j++) {
                        matrix[i][j] -= matrix[i][col] * matrix[row][j];
                    }
                    matrix[i][col] = 0;
                }
            }
        };
        /**
         * Perform gauss-jordan echelon method
         *
         * @param {number[][]|Float32Array[]|Float64Array[]} matrix - gets modified
         * @returns {number[][]|Float32Array[]|Float64Array[]} matrix
         */
        Polyfit.gaussJordanEchelonize = function (matrix) {
            var rows = matrix.length;
            var cols = matrix[0].length;
            var i = 0;
            var j = 0;
            var k;
            var swap;
            while (i < rows && j < cols) {
                k = i;
                // Look for non-zero entries in col j at or below row i
                while (k < rows && matrix[k][j] === 0) {
                    k++;
                }
                // If an entry is found at row k
                if (k < rows) {
                    // If k is not i, then swap row i with row k
                    if (k !== i) {
                        swap = matrix[i];
                        matrix[i] = matrix[k];
                        matrix[k] = swap;
                    }
                    // If matrix[i][j] is != 1, divide row i by matrix[i][j]
                    if (matrix[i][j] !== 1) {
                        Polyfit.gaussJordanDivide(matrix, i, j, cols);
                    }
                    // Eliminate all other non-zero entries
                    Polyfit.gaussJordanEliminate(matrix, i, j, rows, cols);
                    i++;
                }
                j++;
            }
            return matrix;
        };
        /**
         * Perform regression
         *
         * @param {number} x
         * @param {number[]|Float32Array[]|Float64Array[]} terms
         * @returns {number}
         */
        Polyfit.regress = function (x, terms) {
            var a = 0;
            var exp = 0;
            for (var i = 0, len = terms.length; i < len; i++) {
                a += terms[i] * Math.pow(x, exp++);
            }
            return a;
        };
        /**
         * Compute correlation coefficient
         *
         * @param {number[]|Float32Array[]|Float64Array[]} terms
         * @returns {number}
         */
        Polyfit.prototype.correlationCoefficient = function (terms) {
            var r = 0;
            var n = this.x.length;
            var sx = 0;
            var sx2 = 0;
            var sy = 0;
            var sy2 = 0;
            var sxy = 0;
            var x;
            var y;
            for (var i = 0; i < n; i++) {
                x = Polyfit.regress(this.x[i], terms);
                y = this.y[i];
                sx += x;
                sy += y;
                sxy += x * y;
                sx2 += x * x;
                sy2 += y * y;
            }
            var div = Math.sqrt((sx2 - (sx * sx) / n) * (sy2 - (sy * sy) / n));
            if (div !== 0) {
                r = Math.pow((sxy - (sx * sy) / n) / div, 2);
            }
            return r;
        };
        /**
         * Run standard error function
         *
         * @param {number[]|Float32Array[]|Float64Array[]} terms
         * @returns number
         */
        Polyfit.prototype.standardError = function (terms) {
            var r = 0;
            var n = this.x.length;
            if (n > 2) {
                var a = 0;
                for (var i = 0; i < n; i++) {
                    a += Math.pow((Polyfit.regress(this.x[i], terms) - this.y[i]), 2);
                }
                r = Math.sqrt(a / (n - 2));
            }
            return r;
        };
        /**
         * Compute coefficients for given data matrix
         *
         * @param {number} p
         * @returns {number[]|Float32Array|Float64Array}
         */
        Polyfit.prototype.computeCoefficients = function (p) {
            var n = this.x.length;
            var r;
            var c;
            var rs = 2 * (++p) - 1;
            var i;
            var m = [];
            // Initialize array with 0 values
            if (this.FloatXArray) {
                // fast FloatXArray-Matrix init
                var bytesPerRow = (p + 1) * this.FloatXArray.BYTES_PER_ELEMENT;
                var buffer = new ArrayBuffer(p * bytesPerRow);
                for (i = 0; i < p; i++) {
                    m[i] = new this.FloatXArray(buffer, i * bytesPerRow, p + 1);
                }
            }
            else {
                var zeroRow = [];
                for (i = 0; i <= p; i++) {
                    zeroRow[i] = 0;
                }
                m[0] = zeroRow;
                for (i = 1; i < p; i++) {
                    // copy zeroRow
                    m[i] = zeroRow.slice();
                }
            }
            var mpc = [n];
            for (i = 1; i < rs; i++) {
                mpc[i] = 0;
            }
            for (i = 0; i < n; i++) {
                var x = this.x[i];
                var y = this.y[i];
                // Process precalculation array
                for (r = 1; r < rs; r++) {
                    mpc[r] += Math.pow(x, r);
                }
                // Process RH column cells
                m[0][p] += y;
                for (r = 1; r < p; r++) {
                    m[r][p] += Math.pow(x, r) * y;
                }
            }
            // Populate square matrix section
            for (r = 0; r < p; r++) {
                for (c = 0; c < p; c++) {
                    m[r][c] = mpc[r + c];
                }
            }
            Polyfit.gaussJordanEchelonize(m);
            var terms = this.FloatXArray && new this.FloatXArray(m.length) || [];
            for (i = m.length - 1; i >= 0; i--) {
                terms[i] = m[i][p];
            }
            return terms;
        };
        /**
         * Using given degree of fitment, return a function that will calculate
         * the y for a given x
         *
         * @param {number} degree  > 0
         * @returns {Function}     f(x) =
         */
        Polyfit.prototype.getPolynomial = function (degree) {
            if (isNaN(degree) || degree < 0) {
                throw new Error('Degree must be a positive integer');
            }
            var terms = this.computeCoefficients(degree);
            var eqParts = [];
            eqParts.push(terms[0].toPrecision());
            for (var i = 1, len = terms.length; i < len; i++) {
                eqParts.push(terms[i] + ' * Math.pow(x, ' + i + ')');
            }
            var expr = 'return ' + eqParts.join(' + ') + ';';
            /* jshint evil: true */
            return new Function('x', expr);
            /* jshint evil: false */
        };
        /**
         * Convert the polynomial to a string expression, mostly useful for visual
         * debugging
         *
         * @param {number} degree
         * @returns {string}
         */
        Polyfit.prototype.toExpression = function (degree) {
            if (isNaN(degree) || degree < 0) {
                throw new Error('Degree must be a positive integer');
            }
            var terms = this.computeCoefficients(degree);
            var eqParts = [];
            var len = terms.length;
            eqParts.push(terms[0].toPrecision());
            for (var i = 1; i < len; i++) {
                eqParts.push(terms[i] + 'x^' + i);
            }
            return eqParts.join(' + ');
        };
        return Polyfit;
    })();
    
    import * as THREE from 'three';
    
    // initial parameters for each camera model
    let coeffBC = { fx: 204.9762, fy: 205.9547, cx: 369.3975, cy: 245.7963, k1: -0.2183, k2: 0.0272, p1: -0.0007, p2: -0.0004};
    let coeffKB = { fx: 211.5827, fy: 211.7854, cx: 358.7755, cy: 242.8017, k1: -0.0522, k2: -0.0033, k3: 0.0098, k4: -0.0066};
    let coeffSC = { c: 0.9902, d: 0.0166, e: -0.000026, cx: 366.2676, cy: 229.1071, a0: 237.1833, a2: -0.0010, a3: -0.0000075, a4: 0.000000014};
    let coeffUCM = { fx: 194.7012, fy: 194.7416, cx: 341.7728, cy: 261.1679, xi: 0.4826, k1: -0.0111, k2: -0.0300, p1: -0.0146, p2: 0.0137};
    let coeffDS = { fx: 238.6252, fy: 236.9726, cx: 352.7578, cy: 240.1932, xi: -0.4419, alpha: 0.4526, k1: -0.1614, k2: 0.0180, p1: 0.0077, p2: 0.0115};
    
    function restore() {
        if (guiParams.model == 'BC') {
            Object.assign(guiParams, coeffBC);
        } else if (guiParams.model == 'KB') {
            Object.assign(guiParams, coeffKB);
        } else if (guiParams.model == 'SC') {
            Object.assign(guiParams, coeffSC);
        } else if (guiParams.model == 'UCM') {
            Object.assign(guiParams, coeffUCM);
        } else if (guiParams.model == 'DS') {
            Object.assign(guiParams, coeffDS);
        }
        updateShaderUniforms();
    }

    const guiParams = {
        model: 'BC',
        restore: restore,
        fx: 500.0, // start with BC model
        fy: 500.0,
        cx: 0.0,
        cy: 0.0,
        k1: 0.0,
        k2: 0.0,
        p1: 0.0,
        p2: 0.0,
        k3: 0.0,
        k4: 0.0,
        c: 0.0,
        d: 0.0,
        e: 0.0,
        a0: 0.0,
        a2: 0.0,
        a3: 0.0,
        xi: 0.0,
        alpha: 0.0
    };

    let scene, camera, renderer, material;
    let gui;
    
    // vertex shader
    const vertexShader = /*glsl*/`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;

    // fragment shader for Brown-Conrady distortion model
    const fragmentShaderBC = /*glsl*/`
        precision highp float;
        uniform sampler2D map;
        uniform vec2 resolution;
        uniform float fx, fy, cx, cy;
        uniform float k1, k2, p1, p2;

        varying vec2 vUv;

        void main() {
            // convert x: (0,1) -> (0,width), y: (0,1) -> (0,height)
            vec2 P_undistorted_px = vUv * resolution;

            // normalized image coordinates
            vec2 P_undistorted_norm = vec2(
                (P_undistorted_px.x - cx) / fx,
                (P_undistorted_px.y - cy) / fy
            );
            
            // pre-compute radial distance
            float r2 = dot(P_undistorted_norm, P_undistorted_norm);

            // apply distortion
            float radial_factor = 1.0 + k1 * r2 + k2 * r2 * r2;
            vec2 tangential_factor = vec2(
                2.0 * p1 * P_undistorted_norm.x * P_undistorted_norm.y + p2 * (r2 + 2.0 * P_undistorted_norm.x * P_undistorted_norm.x),
                p1 * (r2 + 2.0 * P_undistorted_norm.y * P_undistorted_norm.y) + 2.0 * p2 * P_undistorted_norm.x * P_undistorted_norm.y
            );

            vec2 P_distorted_norm = P_undistorted_norm * radial_factor + tangential_factor;

            // convert normalized image coordinates to UV coordinates
            vec2 uv_distorted = P_distorted_norm * vec2(fx, fy) + vec2(cx, cy);
            uv_distorted /= resolution;

            // get color
            if (uv_distorted.x < 0.0 || uv_distorted.x > 1.0 || 
                uv_distorted.y < 0.0 || uv_distorted.y > 1.0) {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
            } else {
                gl_FragColor = texture2D(map, uv_distorted);
            }
        }
    `;

    // fragment shader for Kannala-Brandt camera model
    const fragmentShaderKB = /* glsl */`

        precision highp float;
        uniform sampler2D map;
        uniform vec2 resolution;
        uniform float fx, fy, cx, cy;
        uniform float k1, k2, k3, k4;

        varying vec2 vUv;

        void main() {
            // convert x: (0,1) -> (0,width), y: (0,1) -> (0,height)
            vec2 P_undistorted_px = vUv * resolution;

            // normalized image coordinates
            vec2 P_undistorted_norm = vec2(
                (P_undistorted_px.x - cx) / fx,
                (P_undistorted_px.y - cy) / fy
            );
            
            // pre-compute radial distance and angle from z-axis
            float r = sqrt(dot(P_undistorted_norm, P_undistorted_norm));
            float theta = atan(r, 1.0);
            float theta2 = theta * theta;
            float theta4 = theta2 * theta2;
            float theta6 = theta4 * theta2;
            float theta8 = theta4 * theta4;

            // apply Kannala-Brandt polynomial to get distorted radius rd
            float rd = theta * (1.0 + k1*theta2 + k2*theta4 + k3*theta6 + k4*theta8);

            vec2 P_distorted_norm = vec2(
                P_undistorted_norm.x * rd / r,
                P_undistorted_norm.y * rd / r
            );

            // convert normalized image coordinates to UV coordinates
            vec2 uv_distorted = P_distorted_norm * vec2(fx, fy) + vec2(cx, cy);
            uv_distorted /= resolution;

            // get color
            if (uv_distorted.x < 0.0 || uv_distorted.x > 1.0 || 
                uv_distorted.y < 0.0 || uv_distorted.y > 1.0) {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
            } else {
                gl_FragColor = texture2D(map, uv_distorted);
            }
        }
    `;

    // fragment shader for Scaramuzza camera model
    const fragmentShaderSC = /* glsl */`
        precision highp float;
        uniform sampler2D map;
        uniform vec2 resolution;
        uniform float c, d, e, cx, cy;
        uniform float a0, a2, a3, a4;
        uniform float b0, b1, b2, b3, b4, b5, b6, b7, b8, b9; // the degree of the inverse polynomial

        varying vec2 vUv;

        void main() {
            // convert x: (0,1) -> (0,width), y: (0,1) -> (0,height)
            vec2 P_undistorted_px = vUv * resolution;

            float fx = c * a0;
            float fy = a0;

            // normalized image coordinates
            vec2 P_undistorted_norm = vec2(
                (P_undistorted_px.x - cx) / fx,
                (P_undistorted_px.y - cy) / fy
            );
            
            // pre-compute radial distance and angle from z-axis
            float r = sqrt(dot(P_undistorted_norm, P_undistorted_norm));
            float theta = atan(r, 1.0);
            float theta2 = theta * theta;
            float theta3 = theta2 * theta;
            float theta4 = theta2 * theta2;
            float theta5 = theta3 * theta2;
            float theta6 = theta3 * theta3;
            float theta7 = theta4 * theta3;
            float theta8 = theta4 * theta4;
            float theta9 = theta5 * theta4;

            // compute the root of Scaramuzza polynomial using its inverse form
            float rho = b0 + b1*theta + b2*theta2 + b3*theta3 + b4*theta4 + b5*theta5 + b6*theta6 + b7*theta7 + b8*theta8 + b9*theta9;

            vec2 P_distorted_xy = vec2(
                P_undistorted_norm.x * rho / r,
                P_undistorted_norm.y * rho / r
            );

            // convert normalized image coordinates to UV coordinates
            vec2 uv_distorted = P_distorted_xy.xx * vec2(c, e) + P_distorted_xy.yy * vec2(d, 1.0) + vec2(cx, cy);
            uv_distorted /= resolution;

            // get color
            if (uv_distorted.x < 0.0 || uv_distorted.x > 1.0 || 
                uv_distorted.y < 0.0 || uv_distorted.y > 1.0) {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
            } else {
                gl_FragColor = texture2D(map, uv_distorted);
            }
        }
    `;

    // fragment shader for Unified (Mei) camera model
    const fragmentShaderUCM = /* glsl */`

        precision highp float;
        uniform sampler2D map;
        uniform vec2 resolution;
        uniform float fx, fy, cx, cy;
        uniform float xi, k1, k2, p1, p2;

        varying vec2 vUv;

        void main() {
            // convert x: (0,1) -> (0,width), y: (0,1) -> (0,height)
            vec2 P_undistorted_px = vUv * resolution;

            // normalized image coordinates
            vec2 P_undistorted_norm = vec2(
                (P_undistorted_px.x - cx) / fx,
                (P_undistorted_px.y - cy) / fy
            );
            
            // pre-compute radial distance
            float d = sqrt(dot(P_undistorted_norm, P_undistorted_norm)+1.0); // z^2 = 1.0

            vec2 P_distorted_norm = P_undistorted_norm / (1.0 + xi*d); // z = 1.0

            // pre-compute radial distance
            float r2 = dot(P_distorted_norm, P_distorted_norm);

            // apply distortion
            float radial_factor = 1.0 + k1 * r2 + k2 * r2 * r2;
            vec2 tangential_factor = vec2(
                2.0 * p1 * P_distorted_norm.x * P_distorted_norm.y + p2 * (r2 + 2.0 * P_distorted_norm.x * P_distorted_norm.x),
                p1 * (r2 + 2.0 * P_distorted_norm.y * P_distorted_norm.y) + 2.0 * p2 * P_distorted_norm.x * P_distorted_norm.y
            );

            vec2 P_distorted_xy = P_distorted_norm * radial_factor + tangential_factor;

            // convert normalized image coordinates to UV coordinates
            vec2 uv_distorted = P_distorted_xy * vec2(fx, fy) + vec2(cx, cy);
            uv_distorted /= resolution;

            // get color
            if (uv_distorted.x < 0.0 || uv_distorted.x > 1.0 || 
                uv_distorted.y < 0.0 || uv_distorted.y > 1.0) {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
            } else {
                gl_FragColor = texture2D(map, uv_distorted);
            }
        }
    `;

    // fragment shader for Double Sphere camera model
    const fragmentShaderDS = /* glsl */`

        precision highp float;
        uniform sampler2D map;
        uniform vec2 resolution;
        uniform float fx, fy, cx, cy;
        uniform float xi, alpha, k1, k2, p1, p2;

        varying vec2 vUv;

        void main() {
            // convert x: (0,1) -> (0,width), y: (0,1) -> (0,height)
            vec2 P_undistorted_px = vUv * resolution;

            // normalized image coordinates
            vec2 P_undistorted_norm = vec2(
                (P_undistorted_px.x - cx) / fx,
                (P_undistorted_px.y - cy) / fy
            );
            
            // pre-compute radial distance and angle from z-axis
            float d1 = sqrt(dot(P_undistorted_norm, P_undistorted_norm)+1.0); // z^2 = 1.0
            float d2 = sqrt(dot(P_undistorted_norm, P_undistorted_norm)+pow(1.0+xi*d1, 2.0)); // z = 1.0

            vec2 P_distorted_norm = P_undistorted_norm * (1.0 - alpha) / ((1.0 - alpha) * (1.0 + xi * d1) + alpha*d2); // z = 1.0

            // pre-compute radial distance
            float r2 = dot(P_distorted_norm, P_distorted_norm);

            // apply distortion
            float radial_factor = 1.0 + k1 * r2 + k2 * r2 * r2;
            vec2 tangential_factor = vec2(
                2.0 * p1 * P_distorted_norm.x * P_distorted_norm.y + p2 * (r2 + 2.0 * P_distorted_norm.x * P_distorted_norm.x),
                p1 * (r2 + 2.0 * P_distorted_norm.y * P_distorted_norm.y) + 2.0 * p2 * P_distorted_norm.x * P_distorted_norm.y
            );

            vec2 P_distorted_xy = P_distorted_norm * radial_factor + tangential_factor;

            // convert normalized image coordinates to UV coordinates
            vec2 uv_distorted = P_distorted_xy * vec2(fx, fy) + vec2(cx, cy);
            uv_distorted /= resolution;

            // get color
            if (uv_distorted.x < 0.0 || uv_distorted.x > 1.0 || 
                uv_distorted.y < 0.0 || uv_distorted.y > 1.0) {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
            } else {
                gl_FragColor = texture2D(map, uv_distorted);
            }
        }
    `;

    function init() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        scene = new THREE.Scene();
        camera = new THREE.OrthographicCamera(
            -width/2, width/2,
            -height/2, -height/2,
            1, 1000
        );
        camera.position.z = 10;

        const canvas = document.getElementById('webgl');
        renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        renderer.setSize(width, height);

        // load image
        const loader = new THREE.TextureLoader();
        const texture = loader.load(
            '/assets/image/texture/fisheye_image.jpg',
            (tex) => {
                const imgWidth = tex.image.width;
                const imgHeight = tex.image.height;
                
                // update orthogonal camera
                camera.left = -imgWidth/2;
                camera.right = imgWidth/2;
                camera.top = imgHeight/2;
                camera.bottom = -imgHeight/2;
                camera.updateProjectionMatrix();

                // update uniforms
                material.uniforms.resolution.value.set(imgWidth, imgHeight);

                // resize
                onWindowResize();
                
                animate();
            },
            undefined,
            (err) => {
                console.error('cannot load an image', err);
            }
        );

        let uniforms = {
            map: { value: texture },
            resolution: { value: new THREE.Vector2(width, height) },
            
            fx: { value: guiParams.fx },
            fy: { value: guiParams.fy },
            cx: { value: guiParams.cx },
            cy: { value: guiParams.cy },

            k1: { value: guiParams.k1 },
            k2: { value: guiParams.k2 },
            p1: { value: guiParams.p1 },
            p2: { value: guiParams.p2 },

            // for only Kannala-Brandt
            k3: { value: guiParams.k3 },
            k4: { value: guiParams.k4 },

            // for only the inverse form of Scaramuzza polynomial
            c: { value: 0.0 },
            d: { value: 0.0 },
            e: { value: 0.0 },

            a0: { value: 0.0 },
            a2: { value: 0.0 },
            a3: { value: 0.0 },
            a4: { value: 0.0 },

            b0: { value: 0.0 },
            b1: { value: 0.0 },
            b2: { value: 0.0 },
            b3: { value: 0.0 },
            b4: { value: 0.0 },
            b5: { value: 0.0 },
            b6: { value: 0.0 },
            b7: { value: 0.0 },
            b8: { value: 0.0 },
            b9: { value: 0.0 },

            xi: { value: 0.0 }, // for UCM and DS
            alpha: { value: 0.0 } // for DS
        };
        
        // shader material
        material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: vertexShader,
            fragmentShader: fragmentShaderBC
        });

        // create image plane
        const geometry = new THREE.PlaneGeometry(1, 1); // 초기값 (텍스처 로드 후 크기 조정)
        const mesh = new THREE.Mesh(geometry, material);
        mesh.scale.set(width, height, 1); // 스케일을 초기 화면 크기로 설정
        scene.add(mesh);

        // initialize dat.gui
        initGui();

        // initial intrinsic parameters
        restore();

        // add resize event listener
        window.addEventListener('resize', onWindowResize, false);

        function toggleFullscreen(status) {
            const wrapperDom = document.getElementById('wrapper');
            const enterFullscreenDom = document.getElementById('enterFullscreen');
            const leaveFullscreenDom = document.getElementById('leaveFullscreen');

            if (status) {
                document.body.style.overflowY = 'hidden';

                wrapperDom.style.position = 'fixed';
                wrapperDom.style.top = '0';
                wrapperDom.style.left = '0';
                wrapperDom.style.height = '100vh';
                wrapperDom.style.zIndex = '1000';

                enterFullscreenDom.style.visibility = 'hidden';
                leaveFullscreenDom.style.visibility = 'visible';
            }
            else {
                document.body.style.overflowY = '';

                wrapperDom.style.position = '';
                wrapperDom.style.top = '';
                wrapperDom.style.left = '';
                wrapperDom.style.height = '';
                wrapperDom.style.zIndex = '';

                enterFullscreenDom.style.visibility = 'visible';
                leaveFullscreenDom.style.visibility = 'hidden';
            }

            onWindowResize();
        }

        const enterFullscreenDom = document.getElementById('enterFullscreen');
        const leaveFullscreenDom = document.getElementById('leaveFullscreen');

        enterFullscreenDom.addEventListener('click', ()=>toggleFullscreen(true));
        leaveFullscreenDom.addEventListener('click', ()=>toggleFullscreen(false));

        window.addEventListener('keydown', (event)=>{
            if (event.key == "Escape") toggleFullscreen(false);
        });
    }

    function mergeExistingFields(target, source) {
        for (const key in source)
            if (key in target)
                target[key].value = source[key];
            
        return target;
    }

    function solveQuadraticPolynomial(a, b, c) {
        if (a == 0) {
            if (b == 0) return [];
            else return [math.complex(-c/b)];
        }

        let p = math.complex(b*b - 4*a*c);
        p = math.sqrt(p);

        let roots = [];
        roots.push(math.add(math.complex(-b/2/a), math.multiply(p, 1/2/a)));
        roots.push(math.subtract(math.complex(-b/2/a), math.multiply(p, 1/2/a)));
        return roots;
    }

    function solveCubicPolynomial(a, b, c, d) {
        if (a == 0) return solveQuadraticPolynomial(b, c, d);

        // pre-compute
        let p = math.complex(-b/(3*a));
        let r = math.complex((2*b*b*b - 9*a*b*c + 27*a*a*d)/(27*a*a*a));
        let q = (3*a*c-b*b)/(3*a*a);
        q = math.complex(r*r+4*q*q*q/27);
        let u = math.add(math.multiply(r, math.complex(-0.5)), math.multiply(math.complex(0.5), q.sqrt()));
        let v = math.subtract(math.multiply(r, math.complex(-0.5)), math.multiply(math.complex(0.5), q.sqrt()));
        
        // find the real cube root
        if (u.re > 0)
            u = math.pow(u, 1/3);
        else
            u = math.multiply(math.complex(-1), math.pow(math.multiply(u, math.complex(-1)), 1/3));
        
        if (v.re > 0)
            v = math.pow(v, 1/3);
        else
            v = math.multiply(math.complex(-1), math.pow(math.multiply(v, math.complex(-1)), 1/3));

        // the roots of w^3 = 1
        const w0 = math.complex(1);
        const w1 = math.complex(-1/2, Math.sqrt(3)/2);
        const w2 = math.complex(-1/2, -Math.sqrt(3)/2);

        // the roots of the cubic polynomial
        let roots = [];
        roots.push(math.add(p, math.add(math.multiply(w0, u), math.multiply(w0, v))));
        roots.push(math.add(p, math.add(math.multiply(w1, u), math.multiply(w2, v))));
        roots.push(math.add(p, math.add(math.multiply(w2, u), math.multiply(w1, v))));
        return roots;
    }

    function solveQuarticPolynomial(a, b, c, d, e) {
        if (a == 0) return solveCubicPolynomial(b, c, d, e);

        // depressed quartic substitution
        let p = b/(4*a);
        let q = (8*a*c - 3*b*b)/(8*a*a);
        let r = (b*b*b - 4*a*b*c + 8*a*a*d)/(8*a*a*a);
        let s = (-3*b*b*b*b + 256*a*a*a*e - 64*a*a*b*d + 16*a*b*b*c)/(256*a*a*a*a);

        // solve the resolvent cubic
        let cubicRoots = solveCubicPolynomial(1, 2*q, q*q - 4*s, -r*r);
        let u = cubicRoots[0];
        let v = cubicRoots[1];
        let w = cubicRoots[2];

        // compute the four roots
        let roots = [];
        for (let i = 0; i < 8; i++) {
            let w0 = math.complex(2*(i%2)-1);
            let w1 = math.complex(2*((i>>1)%2)-1);
            let w2 = math.complex(2*((i>>2)%2)-1);

            let x = math.subtract(math.multiply(math.complex(0.5), math.add(math.add(math.multiply(w0, math.sqrt(u)), math.multiply(w1, math.sqrt(v))), math.multiply(w2, math.sqrt(w)))), p);

            if (math.abs(math.add(math.multiply(math.complex(a), math.pow(x, 4)), math.add(math.multiply(math.complex(b), math.pow(x, 3)), math.add(math.multiply(math.complex(c), math.pow(x, 2)), math.add(math.multiply(math.complex(d), x), math.complex(e)))))) < 1e-5) {
                roots.push(x);
            }
        }
        return roots;
    }

    function computeCoeffsInvScaramuzza() {
        let rho = [];
        let a0 = guiParams.a0;
        let a2 = guiParams.a2;
        let a3 = guiParams.a3;
        let a4 = coeffSC.a4;
        
        for (let theta = 0; theta < Math.PI*0.9; theta += Math.PI*0.9/100) {
            let r_n = solveQuarticPolynomial(a4, a3, a2, -Math.tan(Math.PI*0.5 - theta), a0);
            r_n = r_n.filter(x => !isNaN(x) && x.re >= 0 && math.abs(x.im) < 1e-5);

            if (r_n.length > 0) {
                rho.push(Math.min(...r_n));
            }else
                rho.push(NaN);
        }

        let theta = Array.from({length: 100}, (_, i) => 0 + Math.PI*0.9/100 * i);
        let isValid = rho.map(x => !isNaN(x));
        theta = theta.filter((_, idx) => isValid[idx]);
        rho = rho.filter((_, idx) => isValid[idx]);

        let poly = new Polyfit(theta, rho);
        let coeffs = poly.computeCoefficients(9);

        material.uniforms.a0.value = a0;
        material.uniforms.a2.value = a2;
        material.uniforms.a3.value = a3;
        material.uniforms.a4.value = a4;

        material.uniforms.b0.value = coeffs[0];
        material.uniforms.b1.value = coeffs[1];
        material.uniforms.b2.value = coeffs[2];
        material.uniforms.b3.value = coeffs[3];
        material.uniforms.b4.value = coeffs[4];
        material.uniforms.b5.value = coeffs[5];
        material.uniforms.b6.value = coeffs[6];
        material.uniforms.b7.value = coeffs[7];
        material.uniforms.b8.value = coeffs[8];
        material.uniforms.b9.value = coeffs[9];
    }

    function updateShaderUniforms() {
        if (guiParams.model == 'BC') {
            material.fragmentShader = fragmentShaderBC;
        } else if (guiParams.model == 'KB') {
            material.fragmentShader = fragmentShaderKB;
        } else if (guiParams.model == 'SC') {
            material.fragmentShader = fragmentShaderSC;
        } else if (guiParams.model == 'UCM') {
            material.fragmentShader = fragmentShaderUCM;
        } else if (guiParams.model == 'DS') {
            material.fragmentShader = fragmentShaderDS;
        }

        // compute and update the coefficient of the inverse Scaramuzza polynomial
        if (guiParams.model == 'SC')
            computeCoeffsInvScaramuzza();

        mergeExistingFields(material.uniforms, guiParams);
        material.needsUpdate = true;
    };

    function initGui() {
        const updateGUI = () => {
            try {
                if (gui && gui.domElement && gui.domElement.parentNode) {
                   gui.domElement.parentNode.removeChild(gui.domElement);
                }

            } catch (e) {
                console.warn('Error destroying GUI:', e);
            }

            gui = new dat.GUI({ name: 'Distortion parameters' });
            
            const canvasContainer = document.getElementById("wrapper");
            canvasContainer.appendChild(gui.domElement);
            gui.domElement.style.marginRight = '0px';
            gui.domElement.style.position = 'absolute';
            gui.domElement.style.top = '0px';
            gui.domElement.style.right = '0px';

            // common item
            gui.add(guiParams, 'model', {'Brown-Conrady': 'BC', 'Kannala-Brandt': 'KB', 'Scaramuzza': 'SC', 'Unified CM': 'UCM', 'Double Sphere': 'DS'}).name('Model').listen().onChange(updateModel);
            gui.add(guiParams, 'restore').name('Restore');

            if (guiParams.model == 'SC') {
                gui.add(guiParams, 'c', 0.1, 10.0).step(0.001).name('c').onChange(updateShaderUniforms).listen();
                gui.add(guiParams, 'd', -5.0, 5.0).step(0.001).name('d').onChange(updateShaderUniforms).listen();
                gui.add(guiParams, 'e', -5.0, 5.0).step(0.001).name('e').onChange(updateShaderUniforms).listen();
            } else {
                gui.add(guiParams, 'fx', 0, 500).step(0.001).name('fx').onChange(updateShaderUniforms).listen();
                gui.add(guiParams, 'fy', 0, 500).step(0.001).name('fy').onChange(updateShaderUniforms).listen();
            }
            gui.add(guiParams, 'cx', 0, 500).step(0.001).name('cx').onChange(updateShaderUniforms).listen();
            gui.add(guiParams, 'cy', 0, 500).step(0.001).name('cy').onChange(updateShaderUniforms).listen();

            if (guiParams.model == 'BC') {
                const rad = gui.addFolder('Radial distortion');
                rad.add(guiParams, 'k1', -5.0, 5.0).step(0.001).name('k1').onChange(updateShaderUniforms).listen();
                rad.add(guiParams, 'k2', -5.0, 5.0).step(0.001).name('k2').onChange(updateShaderUniforms).listen();
                rad.open();

                const tan = gui.addFolder('Tangential distortion');
                tan.add(guiParams, 'p1', -0.02, 0.02).step(0.00001).name('p1').onChange(updateShaderUniforms).listen();
                tan.add(guiParams, 'p2', -0.02, 0.02).step(0.00001).name('p2').onChange(updateShaderUniforms).listen();
                tan.open();
            } else if (guiParams.model == 'KB') {
                const dist = gui.addFolder('Angular distortion');
                dist.add(guiParams, 'k1', -1.0, 1.0).step(0.001).name('k1').onChange(updateShaderUniforms).listen();
                dist.add(guiParams, 'k2', -1.0, 1.0).step(0.001).name('k2').onChange(updateShaderUniforms).listen();
                dist.add(guiParams, 'k3', -1.0, 1.0).step(0.001).name('k3').onChange(updateShaderUniforms).listen();
                dist.add(guiParams, 'k4', -1.0, 1.0).step(0.001).name('k4').onChange(updateShaderUniforms).listen();
                dist.open();
            } else if (guiParams.model == 'SC') {
                const dist = gui.addFolder('Polynomial coefficients');
                dist.add(guiParams, 'a0', 0.0, 300.0).step(0.001).name('a0').onChange(updateShaderUniforms).listen();
                dist.add(guiParams, 'a2', -0.01, 0.01).step(0.0001).name('a2').onChange(updateShaderUniforms).listen();
                dist.add(guiParams, 'a3', -0.0001, 0.0001).step(0.000001).name('a3').onChange(updateShaderUniforms).listen();
                dist.open();
            } else if (guiParams.model == 'UCM') {
                gui.add(guiParams, 'xi', -1.0, 1.0).step(0.001).name('xi').onChange(updateShaderUniforms).listen();

                const rad = gui.addFolder('Radial distortion');
                rad.add(guiParams, 'k1', -5.0, 5.0).step(0.001).name('k1').onChange(updateShaderUniforms).listen();
                rad.add(guiParams, 'k2', -5.0, 5.0).step(0.001).name('k2').onChange(updateShaderUniforms).listen();
                rad.open();

                const tan = gui.addFolder('Tangential distortion');
                tan.add(guiParams, 'p1', -0.02, 0.02).step(0.00001).name('p1').onChange(updateShaderUniforms).listen();
                tan.add(guiParams, 'p2', -0.02, 0.02).step(0.00001).name('p2').onChange(updateShaderUniforms).listen();
                tan.open();
            } else if (guiParams.model == 'DS') {
                gui.add(guiParams, 'xi', -1.0, 1.0).step(0.001).name('xi').onChange(updateShaderUniforms).listen();
                gui.add(guiParams, 'alpha', 0.0, 1.0).step(0.001).name('alpha').onChange(updateShaderUniforms).listen();

                const rad = gui.addFolder('Radial distortion');
                rad.add(guiParams, 'k1', -5.0, 5.0).step(0.001).name('k1').onChange(updateShaderUniforms).listen();
                rad.add(guiParams, 'k2', -5.0, 5.0).step(0.001).name('k2').onChange(updateShaderUniforms).listen();
                rad.open();

                const tan = gui.addFolder('Tangential distortion');
                tan.add(guiParams, 'p1', -1.0, 1.0).step(0.001).name('p1').onChange(updateShaderUniforms).listen();
                tan.add(guiParams, 'p2', -1.0, 1.0).step(0.001).name('p2').onChange(updateShaderUniforms).listen();
                tan.open();
            }
        }

        const updateModel = () => {
            if (guiParams.model == 'BC') {
                Object.assign(guiParams, coeffBC);
            } else if (guiParams.model == 'KB') {
                Object.assign(guiParams, coeffKB);
            } else if (guiParams.model == 'SC') {
                Object.assign(guiParams, coeffSC);
            } else if (guiParams.model == 'UCM') {
                Object.assign(guiParams, coeffUCM);
            } else if (guiParams.model == 'DS') {
                Object.assign(guiParams, coeffDS);
            }

            updateGUI();
            updateShaderUniforms();
        }

        updateGUI();
        updateShaderUniforms();
    }

    function onWindowResize() {

        const wrapperDom = document.getElementById('wrapper');

        const width = wrapperDom.clientWidth;
        const height = wrapperDom.clientHeight;

        const canvas = document.getElementById('webgl');
        canvas.width = width * window.devicePixelRatio;
        canvas.height = height * window.devicePixelRatio;

        renderer.setSize(width, height);

        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        
        // maintain aspect ratio of image plane
        const mesh = scene.children[0];
        if (mesh && material.uniforms.resolution.value.x > 0) {
            const imgWidth = material.uniforms.resolution.value.x;
            const imgHeight = material.uniforms.resolution.value.y;
            const imgAspect = imgWidth / imgHeight;
            const screenAspect = width / height;

            let planeWidth, planeHeight;

            if (screenAspect > imgAspect) {
                // 화면이 이미지보다 넓음: 높이에 맞추고 너비는 계산
                planeHeight = height;
                planeWidth = height * imgAspect;
            } else {
                // 화면이 이미지보다 좁음: 너비에 맞추고 높이는 계산
                planeWidth = width;
                planeHeight = width / imgAspect;
            }

            mesh.scale.set(planeWidth, planeHeight, 1);
            
            camera.left = -width/2;
            camera.right = width/2;
            camera.top = height/2;
            camera.bottom = -height/2;
            camera.updateProjectionMatrix();
        }
    }

    // render
    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }

    window.onload = init;

</script>